{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/dell/Desktop/Info/Projects/RedditClient/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _createForOfIteratorHelper from \"C:/Users/dell/Desktop/Info/Projects/RedditClient/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"C:/Users/dell/Desktop/Info/Projects/RedditClient/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"C:/Users/dell/Desktop/Info/Projects/RedditClient/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"C:/Users/dell/Desktop/Info/Projects/RedditClient/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/dell/Desktop/Info/Projects/RedditClient/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { StrategyHandler } from './StrategyHandler.js';\nimport './_version.js';\n/**\n * An abstract base class that all other strategy classes must extend from:\n *\n * @memberof module:workbox-strategies\n */\n\nvar Strategy = /*#__PURE__*/function () {\n  /**\n   * Creates a new instance of the strategy and sets all documented option\n   * properties as public instance properties.\n   *\n   * Note: if a custom strategy class extends the base Strategy class and does\n   * not need more than these properties, it does not need to define its own\n   * constructor.\n   *\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] Cache name to store and retrieve\n   * requests. Defaults to the cache names provided by\n   * [workbox-core]{@link module:workbox-core.cacheNames}.\n   * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} [options.fetchOptions] Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n   * `fetch()` requests made by this strategy.\n   * @param {Object} [options.matchOptions] The\n   * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n   * for any `cache.match()` or `cache.put()` calls made by this strategy.\n   */\n  function Strategy() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Strategy);\n\n    /**\n     * Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     *\n     * @type {string}\n     */\n    this.cacheName = cacheNames.getRuntimeName(options.cacheName);\n    /**\n     * The list\n     * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * used by this strategy.\n     *\n     * @type {Array<Object>}\n     */\n\n    this.plugins = options.plugins || [];\n    /**\n     * Values passed along to the\n     * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n     * of all fetch() requests made by this strategy.\n     *\n     * @type {Object}\n     */\n\n    this.fetchOptions = options.fetchOptions;\n    /**\n     * The\n     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     *\n     * @type {Object}\n     */\n\n    this.matchOptions = options.matchOptions;\n  }\n  /**\n   * Perform a request strategy and returns a `Promise` that will resolve with\n   * a `Response`, invoking all relevant plugin callbacks.\n   *\n   * When a strategy instance is registered with a Workbox\n   * [route]{@link module:workbox-routing.Route}, this method is automatically\n   * called when the route matches.\n   *\n   * Alternatively, this method can be used in a standalone `FetchEvent`\n   * listener by passing it to `event.respondWith()`.\n   *\n   * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n   *     properties listed below.\n   * @param {Request|string} options.request A request to run this strategy for.\n   * @param {ExtendableEvent} options.event The event associated with the\n   *     request.\n   * @param {URL} [options.url]\n   * @param {*} [options.params]\n   */\n\n\n  _createClass(Strategy, [{\n    key: \"handle\",\n    value: function handle(options) {\n      var _this$handleAll = this.handleAll(options),\n          _this$handleAll2 = _slicedToArray(_this$handleAll, 1),\n          responseDone = _this$handleAll2[0];\n\n      return responseDone;\n    }\n    /**\n     * Similar to [`handle()`]{@link module:workbox-strategies.Strategy~handle}, but\n     * instead of just returning a `Promise` that resolves to a `Response` it\n     * it will return an tuple of [response, done] promises, where the former\n     * (`response`) is equivalent to what `handle()` returns, and the latter is a\n     * Promise that will resolve once any promises that were added to\n     * `event.waitUntil()` as part of performing the strategy have completed.\n     *\n     * You can await the `done` promise to ensure any extra work performed by\n     * the strategy (usually caching responses) completes successfully.\n     *\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n     *     properties listed below.\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     * @return {Array<Promise>} A tuple of [response, done]\n     *     promises that can be used to determine when the response resolves as\n     *     well as when the handler has completed all its work.\n     */\n\n  }, {\n    key: \"handleAll\",\n    value: function handleAll(options) {\n      // Allow for flexible options to be passed.\n      if (options instanceof FetchEvent) {\n        options = {\n          event: options,\n          request: options.request\n        };\n      }\n\n      var event = options.event;\n      var request = typeof options.request === 'string' ? new Request(options.request) : options.request;\n      var params = 'params' in options ? options.params : undefined;\n      var handler = new StrategyHandler(this, {\n        event: event,\n        request: request,\n        params: params\n      });\n\n      var responseDone = this._getResponse(handler, request, event);\n\n      var handlerDone = this._awaitComplete(responseDone, handler, request, event); // Return an array of promises, suitable for use with Promise.all().\n\n\n      return [responseDone, handlerDone];\n    }\n  }, {\n    key: \"_getResponse\",\n    value: function () {\n      var _getResponse2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(handler, request, event) {\n        var response, _iterator, _step, callback, _iterator2, _step2, _callback;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return handler.runCallbacks('handlerWillStart', {\n                  event: event,\n                  request: request\n                });\n\n              case 2:\n                response = undefined;\n                _context.prev = 3;\n                _context.next = 6;\n                return this._handle(request, handler);\n\n              case 6:\n                response = _context.sent;\n\n                if (!(!response || response.type === 'error')) {\n                  _context.next = 9;\n                  break;\n                }\n\n                throw new WorkboxError('no-response', {\n                  url: request.url\n                });\n\n              case 9:\n                _context.next = 38;\n                break;\n\n              case 11:\n                _context.prev = 11;\n                _context.t0 = _context[\"catch\"](3);\n                _iterator = _createForOfIteratorHelper(handler.iterateCallbacks('handlerDidError'));\n                _context.prev = 14;\n\n                _iterator.s();\n\n              case 16:\n                if ((_step = _iterator.n()).done) {\n                  _context.next = 25;\n                  break;\n                }\n\n                callback = _step.value;\n                _context.next = 20;\n                return callback({\n                  error: _context.t0,\n                  event: event,\n                  request: request\n                });\n\n              case 20:\n                response = _context.sent;\n\n                if (!response) {\n                  _context.next = 23;\n                  break;\n                }\n\n                return _context.abrupt(\"break\", 25);\n\n              case 23:\n                _context.next = 16;\n                break;\n\n              case 25:\n                _context.next = 30;\n                break;\n\n              case 27:\n                _context.prev = 27;\n                _context.t1 = _context[\"catch\"](14);\n\n                _iterator.e(_context.t1);\n\n              case 30:\n                _context.prev = 30;\n\n                _iterator.f();\n\n                return _context.finish(30);\n\n              case 33:\n                if (response) {\n                  _context.next = 37;\n                  break;\n                }\n\n                throw _context.t0;\n\n              case 37:\n                if (process.env.NODE_ENV !== 'production') {\n                  logger.log(\"While responding to '\".concat(getFriendlyURL(request.url), \"', \") + \"an \".concat(_context.t0, \" error occurred. Using a fallback response provided by \") + \"a handlerDidError plugin.\");\n                }\n\n              case 38:\n                _iterator2 = _createForOfIteratorHelper(handler.iterateCallbacks('handlerWillRespond'));\n                _context.prev = 39;\n\n                _iterator2.s();\n\n              case 41:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context.next = 48;\n                  break;\n                }\n\n                _callback = _step2.value;\n                _context.next = 45;\n                return _callback({\n                  event: event,\n                  request: request,\n                  response: response\n                });\n\n              case 45:\n                response = _context.sent;\n\n              case 46:\n                _context.next = 41;\n                break;\n\n              case 48:\n                _context.next = 53;\n                break;\n\n              case 50:\n                _context.prev = 50;\n                _context.t2 = _context[\"catch\"](39);\n\n                _iterator2.e(_context.t2);\n\n              case 53:\n                _context.prev = 53;\n\n                _iterator2.f();\n\n                return _context.finish(53);\n\n              case 56:\n                return _context.abrupt(\"return\", response);\n\n              case 57:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[3, 11], [14, 27, 30, 33], [39, 50, 53, 56]]);\n      }));\n\n      function _getResponse(_x, _x2, _x3) {\n        return _getResponse2.apply(this, arguments);\n      }\n\n      return _getResponse;\n    }()\n  }, {\n    key: \"_awaitComplete\",\n    value: function () {\n      var _awaitComplete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(responseDone, handler, request, event) {\n        var response, error;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return responseDone;\n\n              case 3:\n                response = _context2.sent;\n                _context2.next = 8;\n                break;\n\n              case 6:\n                _context2.prev = 6;\n                _context2.t0 = _context2[\"catch\"](0);\n\n              case 8:\n                _context2.prev = 8;\n                _context2.next = 11;\n                return handler.runCallbacks('handlerDidRespond', {\n                  event: event,\n                  request: request,\n                  response: response\n                });\n\n              case 11:\n                _context2.next = 13;\n                return handler.doneWaiting();\n\n              case 13:\n                _context2.next = 18;\n                break;\n\n              case 15:\n                _context2.prev = 15;\n                _context2.t1 = _context2[\"catch\"](8);\n                error = _context2.t1;\n\n              case 18:\n                _context2.next = 20;\n                return handler.runCallbacks('handlerDidComplete', {\n                  event: event,\n                  request: request,\n                  response: response,\n                  error: error\n                });\n\n              case 20:\n                handler.destroy();\n\n                if (!error) {\n                  _context2.next = 23;\n                  break;\n                }\n\n                throw error;\n\n              case 23:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[0, 6], [8, 15]]);\n      }));\n\n      function _awaitComplete(_x4, _x5, _x6, _x7) {\n        return _awaitComplete2.apply(this, arguments);\n      }\n\n      return _awaitComplete;\n    }()\n  }]);\n\n  return Strategy;\n}();\n\nexport { Strategy };\n/**\n * Classes extending the `Strategy` based class should implement this method,\n * and leverage the [`handler`]{@link module:workbox-strategies.StrategyHandler}\n * arg to perform all fetching and cache logic, which will ensure all relevant\n * cache, cache options, fetch options and plugins are used (per the current\n * strategy instance).\n *\n * @name _handle\n * @instance\n * @abstract\n * @function\n * @param {Request} request\n * @param {module:workbox-strategies.StrategyHandler} handler\n * @return {Promise<Response>}\n *\n * @memberof module:workbox-strategies.Strategy\n */","map":{"version":3,"sources":["C:/Users/dell/Desktop/Info/Projects/RedditClient/node_modules/workbox-strategies/Strategy.js"],"names":["cacheNames","WorkboxError","logger","getFriendlyURL","StrategyHandler","Strategy","options","cacheName","getRuntimeName","plugins","fetchOptions","matchOptions","handleAll","responseDone","FetchEvent","event","request","Request","params","undefined","handler","_getResponse","handlerDone","_awaitComplete","runCallbacks","response","_handle","type","url","iterateCallbacks","callback","error","process","env","NODE_ENV","log","doneWaiting","destroy"],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,UAAT,QAA2B,qCAA3B;AACA,SAASC,YAAT,QAA6B,uCAA7B;AACA,SAASC,MAAT,QAAuB,iCAAvB;AACA,SAASC,cAAT,QAA+B,yCAA/B;AACA,SAASC,eAAT,QAAgC,sBAAhC;AACA,OAAO,eAAP;AACA;AACA;AACA;AACA;AACA;;IACMC,Q;AACF;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,sBAA0B;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AAAA;;AACtB;AACR;AACA;AACA;AACA;AACA;AACA;AACQ,SAAKC,SAAL,GAAiBP,UAAU,CAACQ,cAAX,CAA0BF,OAAO,CAACC,SAAlC,CAAjB;AACA;AACR;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKE,OAAL,GAAeH,OAAO,CAACG,OAAR,IAAmB,EAAlC;AACA;AACR;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKC,YAAL,GAAoBJ,OAAO,CAACI,YAA5B;AACA;AACR;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKC,YAAL,GAAoBL,OAAO,CAACK,YAA5B;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;WACI,gBAAOL,OAAP,EAAgB;AACZ,4BAAuB,KAAKM,SAAL,CAAeN,OAAf,CAAvB;AAAA;AAAA,UAAOO,YAAP;;AACA,aAAOA,YAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,mBAAUP,OAAV,EAAmB;AACf;AACA,UAAIA,OAAO,YAAYQ,UAAvB,EAAmC;AAC/BR,QAAAA,OAAO,GAAG;AACNS,UAAAA,KAAK,EAAET,OADD;AAENU,UAAAA,OAAO,EAAEV,OAAO,CAACU;AAFX,SAAV;AAIH;;AACD,UAAMD,KAAK,GAAGT,OAAO,CAACS,KAAtB;AACA,UAAMC,OAAO,GAAG,OAAOV,OAAO,CAACU,OAAf,KAA2B,QAA3B,GACZ,IAAIC,OAAJ,CAAYX,OAAO,CAACU,OAApB,CADY,GAEZV,OAAO,CAACU,OAFZ;AAGA,UAAME,MAAM,GAAG,YAAYZ,OAAZ,GAAsBA,OAAO,CAACY,MAA9B,GAAuCC,SAAtD;AACA,UAAMC,OAAO,GAAG,IAAIhB,eAAJ,CAAoB,IAApB,EAA0B;AAAEW,QAAAA,KAAK,EAALA,KAAF;AAASC,QAAAA,OAAO,EAAPA,OAAT;AAAkBE,QAAAA,MAAM,EAANA;AAAlB,OAA1B,CAAhB;;AACA,UAAML,YAAY,GAAG,KAAKQ,YAAL,CAAkBD,OAAlB,EAA2BJ,OAA3B,EAAoCD,KAApC,CAArB;;AACA,UAAMO,WAAW,GAAG,KAAKC,cAAL,CAAoBV,YAApB,EAAkCO,OAAlC,EAA2CJ,OAA3C,EAAoDD,KAApD,CAApB,CAfe,CAgBf;;;AACA,aAAO,CAACF,YAAD,EAAeS,WAAf,CAAP;AACH;;;;mFACD,iBAAmBF,OAAnB,EAA4BJ,OAA5B,EAAqCD,KAArC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACUK,OAAO,CAACI,YAAR,CAAqB,kBAArB,EAAyC;AAAET,kBAAAA,KAAK,EAALA,KAAF;AAASC,kBAAAA,OAAO,EAAPA;AAAT,iBAAzC,CADV;;AAAA;AAEQS,gBAAAA,QAFR,GAEmBN,SAFnB;AAAA;AAAA;AAAA,uBAIyB,KAAKO,OAAL,CAAaV,OAAb,EAAsBI,OAAtB,CAJzB;;AAAA;AAIQK,gBAAAA,QAJR;;AAAA,sBAQY,CAACA,QAAD,IAAaA,QAAQ,CAACE,IAAT,KAAkB,OAR3C;AAAA;AAAA;AAAA;;AAAA,sBASkB,IAAI1B,YAAJ,CAAiB,aAAjB,EAAgC;AAAE2B,kBAAAA,GAAG,EAAEZ,OAAO,CAACY;AAAf,iBAAhC,CATlB;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA,uDAa+BR,OAAO,CAACS,gBAAR,CAAyB,iBAAzB,CAb/B;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAamBC,gBAAAA,QAbnB;AAAA;AAAA,uBAc6BA,QAAQ,CAAC;AAAEC,kBAAAA,KAAK,aAAP;AAAShB,kBAAAA,KAAK,EAALA,KAAT;AAAgBC,kBAAAA,OAAO,EAAPA;AAAhB,iBAAD,CAdrC;;AAAA;AAcYS,gBAAAA,QAdZ;;AAAA,qBAegBA,QAfhB;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA,oBAmBaA,QAnBb;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAsBa,oBAAIO,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AAC5ChC,kBAAAA,MAAM,CAACiC,GAAP,CAAW,+BAAwBhC,cAAc,CAACa,OAAO,CAACY,GAAT,CAAtC,6HAAX;AAGH;;AA1BT;AAAA,wDA4B2BR,OAAO,CAACS,gBAAR,CAAyB,oBAAzB,CA5B3B;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AA4BeC,gBAAAA,SA5Bf;AAAA;AAAA,uBA6ByBA,SAAQ,CAAC;AAAEf,kBAAAA,KAAK,EAALA,KAAF;AAASC,kBAAAA,OAAO,EAAPA,OAAT;AAAkBS,kBAAAA,QAAQ,EAARA;AAAlB,iBAAD,CA7BjC;;AAAA;AA6BQA,gBAAAA,QA7BR;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA,iDA+BWA,QA/BX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;qFAiCA,kBAAqBZ,YAArB,EAAmCO,OAAnC,EAA4CJ,OAA5C,EAAqDD,KAArD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAIyBF,YAJzB;;AAAA;AAIQY,gBAAAA,QAJR;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA,uBAYcL,OAAO,CAACI,YAAR,CAAqB,mBAArB,EAA0C;AAC5CT,kBAAAA,KAAK,EAALA,KAD4C;AAE5CC,kBAAAA,OAAO,EAAPA,OAF4C;AAG5CS,kBAAAA,QAAQ,EAARA;AAH4C,iBAA1C,CAZd;;AAAA;AAAA;AAAA,uBAiBcL,OAAO,CAACgB,WAAR,EAjBd;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAoBQL,gBAAAA,KAAK,eAAL;;AApBR;AAAA;AAAA,uBAsBUX,OAAO,CAACI,YAAR,CAAqB,oBAArB,EAA2C;AAC7CT,kBAAAA,KAAK,EAALA,KAD6C;AAE7CC,kBAAAA,OAAO,EAAPA,OAF6C;AAG7CS,kBAAAA,QAAQ,EAARA,QAH6C;AAI7CM,kBAAAA,KAAK,EAALA;AAJ6C,iBAA3C,CAtBV;;AAAA;AA4BIX,gBAAAA,OAAO,CAACiB,OAAR;;AA5BJ,qBA6BQN,KA7BR;AAAA;AAAA;AAAA;;AAAA,sBA8BcA,KA9Bd;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;;;AAkCJ,SAAS1B,QAAT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { StrategyHandler } from './StrategyHandler.js';\nimport './_version.js';\n/**\n * An abstract base class that all other strategy classes must extend from:\n *\n * @memberof module:workbox-strategies\n */\nclass Strategy {\n    /**\n     * Creates a new instance of the strategy and sets all documented option\n     * properties as public instance properties.\n     *\n     * Note: if a custom strategy class extends the base Strategy class and does\n     * not need more than these properties, it does not need to define its own\n     * constructor.\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {Object} [options.matchOptions] The\n     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     */\n    constructor(options = {}) {\n        /**\n         * Cache name to store and retrieve\n         * requests. Defaults to the cache names provided by\n         * [workbox-core]{@link module:workbox-core.cacheNames}.\n         *\n         * @type {string}\n         */\n        this.cacheName = cacheNames.getRuntimeName(options.cacheName);\n        /**\n         * The list\n         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n         * used by this strategy.\n         *\n         * @type {Array<Object>}\n         */\n        this.plugins = options.plugins || [];\n        /**\n         * Values passed along to the\n         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n         * of all fetch() requests made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.fetchOptions = options.fetchOptions;\n        /**\n         * The\n         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n         * for any `cache.match()` or `cache.put()` calls made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.matchOptions = options.matchOptions;\n    }\n    /**\n     * Perform a request strategy and returns a `Promise` that will resolve with\n     * a `Response`, invoking all relevant plugin callbacks.\n     *\n     * When a strategy instance is registered with a Workbox\n     * [route]{@link module:workbox-routing.Route}, this method is automatically\n     * called when the route matches.\n     *\n     * Alternatively, this method can be used in a standalone `FetchEvent`\n     * listener by passing it to `event.respondWith()`.\n     *\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n     *     properties listed below.\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     */\n    handle(options) {\n        const [responseDone] = this.handleAll(options);\n        return responseDone;\n    }\n    /**\n     * Similar to [`handle()`]{@link module:workbox-strategies.Strategy~handle}, but\n     * instead of just returning a `Promise` that resolves to a `Response` it\n     * it will return an tuple of [response, done] promises, where the former\n     * (`response`) is equivalent to what `handle()` returns, and the latter is a\n     * Promise that will resolve once any promises that were added to\n     * `event.waitUntil()` as part of performing the strategy have completed.\n     *\n     * You can await the `done` promise to ensure any extra work performed by\n     * the strategy (usually caching responses) completes successfully.\n     *\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n     *     properties listed below.\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     * @return {Array<Promise>} A tuple of [response, done]\n     *     promises that can be used to determine when the response resolves as\n     *     well as when the handler has completed all its work.\n     */\n    handleAll(options) {\n        // Allow for flexible options to be passed.\n        if (options instanceof FetchEvent) {\n            options = {\n                event: options,\n                request: options.request,\n            };\n        }\n        const event = options.event;\n        const request = typeof options.request === 'string' ?\n            new Request(options.request) :\n            options.request;\n        const params = 'params' in options ? options.params : undefined;\n        const handler = new StrategyHandler(this, { event, request, params });\n        const responseDone = this._getResponse(handler, request, event);\n        const handlerDone = this._awaitComplete(responseDone, handler, request, event);\n        // Return an array of promises, suitable for use with Promise.all().\n        return [responseDone, handlerDone];\n    }\n    async _getResponse(handler, request, event) {\n        await handler.runCallbacks('handlerWillStart', { event, request });\n        let response = undefined;\n        try {\n            response = await this._handle(request, handler);\n            // The \"official\" Strategy subclasses all throw this error automatically,\n            // but in case a third-party Strategy doesn't, ensure that we have a\n            // consistent failure when there's no response or an error response.\n            if (!response || response.type === 'error') {\n                throw new WorkboxError('no-response', { url: request.url });\n            }\n        }\n        catch (error) {\n            for (const callback of handler.iterateCallbacks('handlerDidError')) {\n                response = await callback({ error, event, request });\n                if (response) {\n                    break;\n                }\n            }\n            if (!response) {\n                throw error;\n            }\n            else if (process.env.NODE_ENV !== 'production') {\n                logger.log(`While responding to '${getFriendlyURL(request.url)}', ` +\n                    `an ${error} error occurred. Using a fallback response provided by ` +\n                    `a handlerDidError plugin.`);\n            }\n        }\n        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {\n            response = await callback({ event, request, response });\n        }\n        return response;\n    }\n    async _awaitComplete(responseDone, handler, request, event) {\n        let response;\n        let error;\n        try {\n            response = await responseDone;\n        }\n        catch (error) {\n            // Ignore errors, as response errors should be caught via the `response`\n            // promise above. The `done` promise will only throw for errors in\n            // promises passed to `handler.waitUntil()`.\n        }\n        try {\n            await handler.runCallbacks('handlerDidRespond', {\n                event,\n                request,\n                response,\n            });\n            await handler.doneWaiting();\n        }\n        catch (waitUntilError) {\n            error = waitUntilError;\n        }\n        await handler.runCallbacks('handlerDidComplete', {\n            event,\n            request,\n            response,\n            error,\n        });\n        handler.destroy();\n        if (error) {\n            throw error;\n        }\n    }\n}\nexport { Strategy };\n/**\n * Classes extending the `Strategy` based class should implement this method,\n * and leverage the [`handler`]{@link module:workbox-strategies.StrategyHandler}\n * arg to perform all fetching and cache logic, which will ensure all relevant\n * cache, cache options, fetch options and plugins are used (per the current\n * strategy instance).\n *\n * @name _handle\n * @instance\n * @abstract\n * @function\n * @param {Request} request\n * @param {module:workbox-strategies.StrategyHandler} handler\n * @return {Promise<Response>}\n *\n * @memberof module:workbox-strategies.Strategy\n */\n"]},"metadata":{},"sourceType":"module"}